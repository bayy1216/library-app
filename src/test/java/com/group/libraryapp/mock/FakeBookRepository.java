package com.group.libraryapp.mock;

import com.group.libraryapp.core.type.BookCategory;
import com.group.libraryapp.core.type.GetBookSortType;
import com.group.libraryapp.domain.model.book.Book;
import com.group.libraryapp.domain.port.book.BookRepository;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;

import java.util.*;
import java.util.concurrent.atomic.AtomicLong;

public class FakeBookRepository implements BookRepository {
    private final AtomicLong autoGeneratedId = new AtomicLong(0);
    private final List<Book> data = Collections.synchronizedList(new ArrayList<>());
    @Override
    public Optional<Book> findById(Long bookId) {
        return data.stream().filter(b -> b.getId().equals(bookId)).findFirst();
    }

    @Override
    public void delete(Book book) {
        data.removeIf(b -> b.getId().equals(book.getId()));
    }

    @Override
    public Book save(Book book) {
        if(book.getId() == null) {
            Book generated = Book.builder()
                    .id(autoGeneratedId.incrementAndGet())
                    .name(book.getName())
                    .writer(book.getWriter())
                    .category(book.getCategory())
                    .stock(book.getStock())
                    .price(book.getPrice())
                    .build();
            data.add(generated);
            return generated;
        }else{
            data.removeIf(b -> b.getId().equals(book.getId()));
            data.add(book);
            return book;
        }
    }

    @Override
    public Page<Book> getBookPage(int page, String name, String writer, BookCategory category, GetBookSortType sort) {
        var pageRequest = PageRequest.of(page, 20);
        List<Book> content = new ArrayList<>(data);

        if(name != null) content.removeIf(b -> !b.getName().contains(name));
        if(writer != null) content.removeIf(b -> !b.getWriter().contains(writer));
        if(category != null) content.removeIf(b -> !b.getCategory().equals(category));
        switch (sort){
            case STOCK_ASC:
                content.sort(Comparator.comparingInt(Book::getStock));
                break;
            case STOCK_DESC:
                content.sort(Comparator.comparingInt(Book::getStock).reversed());
                break;
            case PRICE_ASC:
                content.sort(Comparator.comparingInt(Book::getPrice));
                break;
            case PRICE_DESC:
                content.sort(Comparator.comparingInt(Book::getPrice).reversed());
                break;
            case NAME_ASC:
                content.sort(Comparator.comparing(Book::getName));
                break;
            case NAME_DESC:
                content.sort(Comparator.comparing(Book::getName).reversed());
                break;
            case DATE_ASC:
                content.sort(Comparator.comparing(Book::getPublishedDate));
                break;
            case DATE_DESC:
                content.sort(Comparator.comparing(Book::getPublishedDate).reversed());
                break;
        }
        int start = (int)pageRequest.getOffset();
        int end = Math.min((start + pageRequest.getPageSize()), content.size());
        return new PageImpl<>(content.subList(start, end), pageRequest, content.size());
    }
}
